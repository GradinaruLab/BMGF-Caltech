# -*- coding: utf-8 -*-
"""
Created on Thu Sep 16 10:49:10 2021

@author: Carrie

Note: get_template() will break with 3.7 or higher
Use environment Caltech_BMGF_MGI which has 3.6 if you need get_template()
Not actually sure if older files will work in this environment...
Queries seem to work normally though with Caltech_BMGF on 3.8

http://www.ncbi.nlm.nih.gov/pubmed/26092688

"""
import pandas as pd
from intermine.webservice import Service
from intermine import registry
import ContraceptiveConstants as cc

#test variables
test_csv = "mgi_test_input.csv" 
test_exp_csv = "mgi_exp_test.csv"


#notes from cc: 
#cc.GS_KEY = "gene symbol" 
#   the name of the column containing gene symbols in the input csv file
#cc.MGI = "MGI_ID"
#   col name for MGI ID


#in_csv = "Top_200_OT.csv" #the input csv file, should be something generated by
#the CITDB/OT/HPA part of this project, but really just needs gene symbols


#out_csv = "Top_200_OT_with_MGI_ID_2021-09-17.csv" #the name of the output file

###### Functions for retrieving mouse orthologs ######
def makeTargetStr(csv_df, col_name):
    """
    Generates a string of comma separated gene symbols from the column 
    col_name in the specified data frame from csvfile. 

    Parameters
    ----------
    csv_df : pandas.dataframe
        the name of the csv file with gene symbols
    col_name : str
        the name of the column containing the gene symbols

    Returns
    -------
    symStr : str
        The a string of comma separated gene symbols

    """
    symStr = ""
    
    for symbol in csv_df[col_name]:
        if symStr == "":
            symStr = symbol
        else:
            symStr = symStr + ", " + str(symbol)
        
    return symStr


def makeMMHomQuery(symStr):
    """
    Given a string of comma separated human gene symbols, queries the MouseMine
    database for homologs in mouse. Uses the MGI data set only. 

    Parameters
    ----------
    symStr : str
        a string of comma separated human gene symbols

    Returns
    -------
    query : intermine.query
        The MouseMine query results for mouse homologues of the list of 
        human gene symbols

    """
    service = Service("http://www.mousemine.org/mousemine/service")
    query = service.new_query("Gene")
    query.add_view(
        "primaryIdentifier", "symbol", "organism.name",
        "homologues.homologue.primaryIdentifier", "homologues.homologue.symbol",
        "homologues.homologue.organism.name", "homologues.type",
        "homologues.dataSets.name"
    )
    query.add_constraint("homologues.type", "NONE OF", 
                         ["horizontal gene transfer",
                            "least diverged horizontal gene transfer"], 
                         code = "B")
    query.add_constraint("Gene", "LOOKUP", symStr, "H. sapiens", 
                         code = "A")
    query.add_constraint("homologues.homologue.organism.name", "=", "Mus musculus",
                         code = "C")
    query.add_constraint("homologues.dataSets.name", "=", 
                         "Mouse/Human Orthologies from MGI",
                         code = "D")
    
    return query

def homologueDF(query, col_name, ID_name = "MGI_ID"):
    """
    Makes a dataframe of gene symbol (in this case, the human gene symbol that
    was used in query generation) index-matched with the MGI ID of their 
    mouse orthologues. Includes multiple orthologues for the same symbol if
    applicable. Genes where no orthologue is found are left blank

    Parameters
    ----------
    query : intermine.query
        A query generated from makeMMHomQuery() containing both the input
        human gene symbols and the MGI ID of their orthologues in mouse.
        
    col_name : str
        The string to be used as a column header for the human gene symbols.
        This should match the column header for gene symbols in the input 
        CSV that the human data came from.
        
    ID_name : str
        The string to be used as the column header for the MGI ID of the 
        mouse orthologues. 

    Returns
    -------
    df : pandas.dataframe
        The data frame containing the human gene symbols index-matched with 
        the MGI ID of their mouse orthologs.

    """
    hList = []
    symList = []
    for r in query.rows():
        symList.append(r["symbol"])
        hList.append(r["homologues.homologue.primaryIdentifier"])
    
    data = {col_name : symList, ID_name : hList}
    df = pd.DataFrame(data)
    return df

    
def printHomQuery(query):
    """
    Prints out useful information about a homologue query

    Parameters
    ----------
    query : intermine.query
        The MouseMine homologue query generated by makeMMQuery()

    Returns
    -------
    None.

    """
    for row in query.rows():
        print(row["primaryIdentifier"], row["symbol"], row["organism.name"], 
            row["homologues.homologue.primaryIdentifier"],
            row["homologues.homologue.symbol"],
            row["homologues.homologue.organism.name"], row["homologues.type"],
            row["homologues.dataSets.name"])

def MGI_ID_wrapper(in_csv, out_csv):
    """
    Generates a csv file with all of the information in the input csv plus
    a column with the MGI_ID of mouse orthologues. Lines for genes with more
    than one possible orthologue are duplicated, so the gene symbol is no 
    longer a unique value. 
    
    Currently takes no input and just uses variables defined at the top of the
    file. At some point I will integrate this with the ContraceptiveConstants
    file. 

    Returns
    -------
    final_df : pandas.dataframe
        A dataframe containing the same info as the csv

    """
    csv_df = pd.read_csv(in_csv, encoding = cc.ENC) 
    ss = makeTargetStr(csv_df, cc.GS_KEY)
    hq = makeMMHomQuery(ss)
    #printHomQuery(hq)
    hdf = homologueDF(hq, cc.GS_KEY)
    final_df = csv_df.merge(hdf, how="outer", on = cc.GS_KEY)
    final_df.to_csv(out_csv, encoding = cc.ENC, index = False)
    
    return final_df
    
#### Functions for retrieving mouse gene expression levels ####

def makeExpQuery(MGI_str):
    """
    Queries MouseMine for gene expression for  

    Parameters
    ----------
    MGI_str : str
        A string of comma-separated MGI ID number of the gene of interest

    Returns
    -------
    query : intermine.query
        The query results for gene expression of the gene of interest

    """
    service = Service("http://www.mousemine.org/mousemine/service")
    query = service.new_query("GXDExpression")
    query.add_view(
        "assayType", "feature.symbol", "feature.primaryIdentifier", 
        "age", "structure.name", "strength", "genotype.symbol", "sex",  
    )
    query.add_sort_order("GXDExpression.structure.name", "DESC")
    #look up all the MGI IDs in the string
    query.add_constraint("feature", "LOOKUP", MGI_str, code = "A")
    query.add_constraint("feature.organism.taxonId", "=", "10090", code = "B")
    #ovary is a parent of itself
    query.add_constraint("structure.parents.name", "=", "ovary", code = "C")
    query.add_constraint("age", ">=", "postnatal day 0", code = "D")
    query.set_logic("A and B and C and D")
    #must be A: specified gene, and B: found in mouse, and C: found in ovary
    #(or a more specific tissue within the ovary), and D: born
    
    return query

def printExpQuery(query):
    """
    Prints some useful info about an expression query

    Parameters
    ----------
    query : intermine.query
        a gene expresssion query

    Returns
    -------
    None.

    """
    for row in query.rows():
        print(row["assayType"], row["feature.symbol"], 
            row["feature.primaryIdentifier"], row["age"], 
            row["structure.name"], row["strength"],  
            row["genotype.symbol"], row["sex"],)
        
        
    
def countLevels(query, MGI_ID, attribute = 'GXDExpression.strength'):
    """
    Counts the 

    Parameters
    ----------
    query : intermine.query
        A gene expression query
    MGI_ID : str
        The ID of the current gene.
    attribute : str
        Which attribute to count levels, for example: 'GXDExpression.strength'
     
    Returns
    -------
    counts : dict
        A dictionary of where the keys are the levels of the attribute and the
        values are the number of times a level occurs in the query. 

    """
    expL = []
    for r in query.rows():
        #if the row is about our gene of interest
        if r['feature.primaryIdentifier'] == MGI_ID:
            #get the expression strength from that row
            exp = r[attribute] 
            expL.append(exp)
        
    counts = {level:expL.count(level) for level in expL}
    return counts



#ovary overall is good, don't need to keep specific structure info right now,
#do keep present/absent/weak/strong breakdown
#add age filtering, only post natal/neonate/adult - we only care about P4-adult
#only single stage in data - don't need stage matrix
#number of studies with yes detected - plot 
#row - gene name, column for how many studies present total
#then, later if more time, add columns for each structure and how many studies
#   found it present/absent/weak/strong in that specific structure


def addCountsToDF(df, MGI_ID, counts_dict):
    """
    Adds the the levels associated with an MGI ID in counts dict to the 
    dataframe. Should create a new column when counts for a novel level are 
    added. Currently adds only levels that are present, doesn't take in a list
    of level names. 

    Parameters
    ----------
    full_df : pandas.dataframe
        dataframe containing a column of unique MGI IDs
    MGI_ID : str
        The MGI ID for the current counts
    counts_dict : TYPE
        A dictionary of counts for each level of an attribute associated
        with the input MGI ID

    Returns
    -------
    full_df : pandas.dataframe
        the updated dataframe with counts

    """
    rowIndex = df[df[cc.MGI] == MGI_ID].index
    for level in counts_dict:    
        df.loc[rowIndex, level] = counts_dict[level]
    return df

    
def collectKeys(counts_dict, keyL):
    """
    Adds unique keys of a dictionary to a list 

    Parameters
    ----------
    counts_dict : dict
        a dictionary of counts
    keyL : list of str
        the ongoing list of unique keys

    Returns
    -------
    keyL : list of str
        the ongoing list of unique keys

    """
    for k in counts_dict.keys():
        if not k in keyL: 
            keyL.append(k)
    return keyL


def NaN_to_zero(df, colL):
    """
    Converts NaN values in the specified columns to zero. 
    
    This is a little redundant because I could just use na_rep when writing
    to csv, but I wrote it and it might be useful so here it stays

    Parameters
    ----------
    df : pandas.dataframe
        The dataframe with NaNs that should be zeros
    colL : TYPE
        the list of columns to convert

    Returns
    -------
    df : pandas.dataframe
        The dataframe with NaNs converted to zeros

    """
    for colName in colL:
        col = df.loc[0:len(df.index), colName]
        for i in range(len(df.index)):
            nullCol = col.isnull()
            if nullCol[i]:
                col[i] = 0
    return df


def MGI_ExpAll(df, MGI_col):
    """
    Queries the MouseMouse for expression levels for all MGI IDs in the 
    dataframe. Creates a column of counts for each expression level. 

    Parameters
    ----------
    df : pandas.dataframe
        a dataframe with a column of MGI IDs
    MGI_col : str
        The name of the column with the MGI IDs

    Returns
    -------
    df : pandas.dataframe
        the input dataframe with columns added with counts for each expression
        level. 

    """
    #comma separated MGI IDs
    MGI_str = makeTargetStr(df, MGI_col)
    exp_levels = [] #for NaN_to_zero
    q = makeExpQuery(MGI_str)
    for MGI_ID in df[MGI_col]:
        counts = countLevels(q, MGI_ID)
        addCountsToDF(df, MGI_ID, counts)
        exp_levels = collectKeys(counts, exp_levels)
    df = NaN_to_zero(df, exp_levels)
    return df


def MGI_exp_wrapper(in_csv, MGI_col, out_csv):
    df = pd.read_csv(in_csv, encoding = cc.ENC)
    final_df = MGI_ExpAll(df, MGI_col)
    final_df.to_csv(out_csv, 
                    encoding = cc.ENC, index = False)
    return df

        

def test_run():
    #q = makeExpQuery('MGI:1349428')
    #printExpQuery(q)
    #counts = countLevels(q, 'GXDExpression.strength')
    #print(counts)
    d = MGI_exp_wrapper(test_exp_csv, cc.MGI, "test_exp_output_2021-09-20.csv")
    return d

#command for 9/20/21 run:
#MGI_exp_wrapper("Top_200_OT_with_MGI_ID_2021-09-16.csv", cc.MGI, 
#                "Top_200_OT_with_Mouse_homolog_expression_2021-09-20.csv")
    
# =============================================================================
# {'GXDExpression.age': 'postnatal adult', 
#  'GXDExpression.annotationDate': '2015-03-12',
#  'GXDExpression.assayId': 'MGI:5618496', 
#  'GXDExpression.assayType': 'Immunohistochemistry', 
#  'GXDExpression.detected': True, 
#  'GXDExpression.emaps': 'EMAPS:3563328', 
#  'GXDExpression.id': 89199676, 
#  'GXDExpression.image': None, 
#  'GXDExpression.note': 'Expression was detected in the granulosa cell layer from the primary follicle stage through the large antral stage.', 
#  'GXDExpression.pattern': 'Regionally restricted', 
#  'GXDExpression.probe': 'MGI:5618495', 
#  'GXDExpression.sex': 'Female', 
#  'GXDExpression.specimenNum': 1, 
#  'GXDExpression.stage': 'TS28', 
#  'GXDExpression.strength': 'Present', 
#  'GXDExpression.feature.symbol': 'Foxl2', 
#  'GXDExpression.feature.primaryIdentifier': 'MGI:1349428', 
#  'GXDExpression.structure.name': 'ovary stratum granulosum', 
#  'GXDExpression.genotype.symbol': None, 
#  'GXDExpression.publication.mgiJnum': 'J:114716'}
# =============================================================================
    
    
    
    
    

