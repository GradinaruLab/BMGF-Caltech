# -*- coding: utf-8 -*-
"""
Created on Thu Sep 16 10:49:10 2021

@author: Carrie

Note: get_template() will break with 3.7 or higher
Use environment Caltech_BMGF_MGI which has 3.6 if you need get_template()
Not actually sure if older files will work in this environment...
Queries seem to work normally though with Caltech_BMGF on 3.8

http://www.ncbi.nlm.nih.gov/pubmed/26092688

"""
import pandas as pd
from intermine.webservice import Service
from intermine import registry

#test variables
test_csv = "mgi_test_input.csv" 

gene_col = "gene symbol" #the name of the column containing gene symbols in
#the input csv file

in_csv = "Top_200_OT.csv" #the input csv file, should be something generated by
#the CITDB/OT/HPA part of this project, but really just needs gene symbols
csv_df = pd.read_csv(in_csv, encoding = 'utf-8-sig') 

out_csv = "Top_200_OT_with_MGI_ID_2021-09-17.csv" #the name of the output file

###### Functions for retrieving mouse orthologs ######
def makeTargetStr(csv_df, col_name):
    """
    Generates a string of comma separated gene symbols from the column 
    col_name in the specified data frame from csvfile. 

    Parameters
    ----------
    csv_df : pandas.dataframe
        the name of the csv file with gene symbols
    col_name : str
        the name of the column containing the gene symbols

    Returns
    -------
    symStr : str
        The a string of comma separated gene symbols

    """
    symStr = ""
    
    for symbol in csv_df[col_name]:
        if symStr == "":
            symStr = symbol
        else:
            symStr = symStr + ", " + symbol
        
    return symStr


def makeMMHomQuery(symStr):
    """
    Given a string of comma separated human gene symbols, queries the MouseMine
    database for homologs in mouse. Uses the MGI data set only. 

    Parameters
    ----------
    symStr : str
        a string of comma separated human gene symbols

    Returns
    -------
    query : intermine.query
        The MouseMine query results for mouse homologues of the list of 
        human gene symbols

    """
    service = Service("http://www.mousemine.org/mousemine/service")
    query = service.new_query("Gene")
    query.add_view(
        "primaryIdentifier", "symbol", "organism.name",
        "homologues.homologue.primaryIdentifier", "homologues.homologue.symbol",
        "homologues.homologue.organism.name", "homologues.type",
        "homologues.dataSets.name"
    )
    query.add_constraint("homologues.type", "NONE OF", 
                         ["horizontal gene transfer",
                            "least diverged horizontal gene transfer"], 
                         code = "B")
    query.add_constraint("Gene", "LOOKUP", symStr, "H. sapiens", 
                         code = "A")
    query.add_constraint("homologues.homologue.organism.name", "=", "Mus musculus",
                         code = "C")
    query.add_constraint("homologues.dataSets.name", "=", 
                         "Mouse/Human Orthologies from MGI",
                         code = "D")
    
    return query

def homologueDF(query, col_name, ID_name = "MGI_ID"):
    """
    Makes a dataframe of gene symbol (in this case, the human gene symbol that
    was used in query generation) index-matched with the MGI ID of their 
    mouse orthologues. Includes multiple orthologues for the same symbol if
    applicable. Genes where no orthologue is found are left blank

    Parameters
    ----------
    query : intermine.query
        A query generated from makeMMHomQuery() containing both the input
        human gene symbols and the MGI ID of their orthologues in mouse.
        
    col_name : str
        The string to be used as a column header for the human gene symbols.
        This should match the column header for gene symbols in the input 
        CSV that the human data came from.
        
    ID_name : str
        The string to be used as the column header for the MGI ID of the 
        mouse orthologues. 

    Returns
    -------
    df : pandas.dataframe
        The data frame containing the human gene symbols index-matched with 
        the MGI ID of their mouse orthologs.

    """
    hList = []
    symList = []
    for r in query.rows():
        symList.append(r["symbol"])
        hList.append(r["homologues.homologue.primaryIdentifier"])
    
    data = {col_name : symList, ID_name : hList}
    df = pd.DataFrame(data)
    return df

    
def printHomQuery(query):
    """
    Prints out useful information about a homologue query

    Parameters
    ----------
    query : intermine.query
        The MouseMine homologue query generated by makeMMQuery()

    Returns
    -------
    None.

    """
    for row in query.rows():
        print(row["primaryIdentifier"], row["symbol"], row["organism.name"], 
            row["homologues.homologue.primaryIdentifier"],
            row["homologues.homologue.symbol"],
            row["homologues.homologue.organism.name"], row["homologues.type"],
            row["homologues.dataSets.name"])

def MGI_ID_wrapper():
    """
    Generates a csv file with all of the information in the input csv plus
    a column with the MGI_ID of mouse orthologues. Lines for genes with more
    than one possible orthologue are duplicated, so the gene symbol is no 
    longer a unique value. 
    
    Currently takes no input and just uses variables defined at the top of the
    file. At some point I will integrate this with the ContraceptiveConstants
    file. 

    Returns
    -------
    final_df : pandas.dataframe
        A dataframe containing the same info as the csv

    """
    ss = makeTargetStr(csv_df, gene_col)
    hq = makeMMHomQuery(ss)
    #printHomQuery(hq)
    hdf = homologueDF(hq, gene_col)
    final_df = csv_df.merge(hdf, how="outer", on = gene_col)
    final_df.to_csv(out_csv, encoding = "utf-8-sig", index = False)
    
    return final_df
    
#### Functions for retrieving mouse gene expression levels ####

def makeExpQuery(MGI_ID):
    """
    Queries MouseMine for gene expression of the given gene using its MGI ID
    number. 

    Parameters
    ----------
    MGI_ID : str
        The MGI ID number of the gene of interest

    Returns
    -------
    query : intermine.query
        The query results for gene expression of the gene of interest

    """
    service = Service("http://www.mousemine.org/mousemine/service")
    query = service.new_query("GXDExpression")
    query.add_view(
        "assayType", "feature.symbol", "feature.primaryIdentifier", "stage", 
        "age", "structure.name", "strength", "pattern", "genotype.symbol", 
        "sex", "assayId", "probe", "image", "publication.mgiJnum"
    )
    query.add_sort_order("GXDExpression.structure.name", "DESC")
    #below line restricts to the gene with specified MGI_ID
    query.add_constraint("feature.primaryIdentifier", "=", MGI_ID, code = "A")
    query.add_constraint("feature.organism.taxonId", "=", "10090", code = "B")
    query.add_constraint("structure.name", "CONTAINS", "ovary", code = "C")
    query.add_constraint("structure.parents.name", "=", "ovary", code = "D")
    query.set_logic("A and B and (C or D)")
    #must be A: specified gene, and B: found in mouse, and either:
    #(C: found in ovary, or D: found in a tissue within the ovary)
    
    return query

def printExpQuery(query):
    for row in query.rows():
        print(row["assayType"], row["feature.symbol"], 
            row["feature.primaryIdentifier"], row["stage"], row["age"], 
            row["structure.name"], row["strength"], row["pattern"], 
            row["genotype.symbol"], row["sex"], row["assayId"], row["probe"], 
            row["image"], row["publication.mgiJnum"])
        
def countLevels(query, view):
    expL = []
    for r in query.rows():
       exp = r[view]
       expL.append(exp)
        
    counts = {level:expL.count(level) for level in expL}
    return counts
#ovary overall is good, don't need to keep specific structure info right now,
#do keep present/absent/weak/strong breakdown
#add age filtering, only post natal/neonate/adult - we only care about P4-adult
#only single stage in data - don't need stage matrix
#number of studies with yes detected - plot 
#row - gene name, column for how many studies present total
#then, later if more time, add columns for each structure and how many studies
#   found it present/absent/weak/strong in that specific structure
def addCountsToDF(full_df, MGI_col, MGI_ID, counts_dict):
    
    pass

def test_run():
    q = makeExpQuery('MGI:1349428')
    printExpQuery(q)
    counts = countLevels(q, 'GXDExpression.strength')
    print(counts)
        
    
# =============================================================================
# {'GXDExpression.age': 'postnatal adult', 
#  'GXDExpression.annotationDate': '2015-03-12',
#  'GXDExpression.assayId': 'MGI:5618496', 
#  'GXDExpression.assayType': 'Immunohistochemistry', 
#  'GXDExpression.detected': True, 
#  'GXDExpression.emaps': 'EMAPS:3563328', 
#  'GXDExpression.id': 89199676, 
#  'GXDExpression.image': None, 
#  'GXDExpression.note': 'Expression was detected in the granulosa cell layer from the primary follicle stage through the large antral stage.', 
#  'GXDExpression.pattern': 'Regionally restricted', 
#  'GXDExpression.probe': 'MGI:5618495', 
#  'GXDExpression.sex': 'Female', 
#  'GXDExpression.specimenNum': 1, 
#  'GXDExpression.stage': 'TS28', 
#  'GXDExpression.strength': 'Present', 
#  'GXDExpression.feature.symbol': 'Foxl2', 
#  'GXDExpression.feature.primaryIdentifier': 'MGI:1349428', 
#  'GXDExpression.structure.name': 'ovary stratum granulosum', 
#  'GXDExpression.genotype.symbol': None, 
#  'GXDExpression.publication.mgiJnum': 'J:114716'}
# =============================================================================
    
    
    
    
    

